-*- mode: org -*-
#+title: Assignment 07
#+subtitle: PQR Number Theory II
#+language: en
#+options: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t d:(not "HINT")
#+startup: entitiespretty showeverything
#+setupfile: theme-bigblow.setup

:HINT:
 Click your mouse on the links below, or with your cursor somewhere in them,
 press the Enter key.

[[elisp:(relocate-file-to-work-folder)][Relocate File to Work Folder]]

[[elisp:(find-file-other-window "generic-instructions.txt")][Read Instructions]]

[[elisp:(browse-url-of-file (org-html-export-to-html))][Export to HTML and Browse]]

[[elisp:(org-clock-report 1)][Insert/Update Clock Summary Report]]
:END:
* Exercises
  :PROPERTIES:
  :ID:       5ccb0c27-f6b1-43e2-bad6-f9c3cfe1e57e
  :END:
** DONE GMQ
   CLOSED: [2020-02-19 Wed 18:22]
#+begin_note
  First recall (or look up) how the =&rest= keyword works, e.g.:

#+begin_src elisp :results silent
  (defun printf (format-directive &rest args)
    (princ (apply 'format format-directive args)))
#+end_src

  Now explain what this code does after trying it on a few tests:

#+begin_src elisp :results silent
  (defun mystery (&rest numbers)
    (loop for n from 0 to (apply '* numbers)
          do (printf "%3d <--> %s\n" n
                     (loop for m in numbers collect (mod n m)))))
#+end_src

#+begin_src elisp :results output
  (mystery 3 5)
#+end_src

#+begin_src elisp :results output
  (mystery 4 6)
#+end_src

  Replace ='*= with ='lcm= and do the same calls again. Explain what you
  observed, and come up with a better name for the =mystery= function.
:HINT:
  - Hint :: In your source code blocks, use the header directive =:results
            output= for best results, e.g.:
: #+begin_src elisp :results output
  - Peek Ahead Hint :: PQU
:END:
#+end_note
#+begin_info
What the mystery function is duing is printing out the lcm of the 2 numbers when modded by
all of the numbers up to the multiple of the two inputs.
A better name for the function would be lcm mod table
#+end_info
#+begin_src elisp :results silent
  (defun printf (format-directive &rest args)
    (princ (apply 'format format-directive args)))
#+end_src

  Now explain what this code does after trying it on a few tests:

#+begin_src elisp :results silent
  (defun mystery (&rest numbers)
    (loop for n from 0 to (apply '* numbers)
          do (printf "%3d <--> %s\n" n
                     (loop for m in numbers collect (mod n m)))))
#+end_src

#+begin_src elisp :results output
  (mystery 3 5)
#+end_src

#+results:
#+begin_example
  0 <--> (0 0)
  1 <--> (1 1)
  2 <--> (2 2)
  3 <--> (0 3)
  4 <--> (1 4)
  5 <--> (2 0)
  6 <--> (0 1)
  7 <--> (1 2)
  8 <--> (2 3)
  9 <--> (0 4)
 10 <--> (1 0)
 11 <--> (2 1)
 12 <--> (0 2)
 13 <--> (1 3)
 14 <--> (2 4)
 15 <--> (0 0)
#+end_example

#+begin_src elisp :results output
  (mystery 4 6)
#+end_src

#+results:
#+begin_example
  0 <--> (0 0)
  1 <--> (1 1)
  2 <--> (2 2)
  3 <--> (3 3)
  4 <--> (0 4)
  5 <--> (1 5)
  6 <--> (2 0)
  7 <--> (3 1)
  8 <--> (0 2)
  9 <--> (1 3)
 10 <--> (2 4)
 11 <--> (3 5)
 12 <--> (0 0)
 13 <--> (1 1)
 14 <--> (2 2)
 15 <--> (3 3)
 16 <--> (0 4)
 17 <--> (1 5)
 18 <--> (2 0)
 19 <--> (3 1)
 20 <--> (0 2)
 21 <--> (1 3)
 22 <--> (2 4)
 23 <--> (3 5)
 24 <--> (0 0)
#+end_example

** DONE GMY
   CLOSED: [2020-02-20 Thu 16:26]
#+begin_note
  Replace the =;;...= line with three lines, binding the values of =y1=, =y2= and
  =y3=. Write a helper function to compute these values.

#+begin_src elisp
  (let* ((r1 4)
         (r2 2)
         (r3 9)
         (m1 7)
         (m2 11)
         (m3 13)
         (m (* m1 m2 m3))
         (o1 (/ m m1))
         (o2 (/ m m2))
         (o3 (/ m m3))
         ;;...
         )
    (mod (+ (* r1 o1 y1) (* r2 o2 y2) (* r3 o3 y3)) m))
#+end_src
:HINT:
  - Hint :: The y\rsquo{}s are just the MMIs of the o\rsquo{}s mod the m\rsquo{}s. The helper
            function should use the Extended Euclidean GCD algorithm to compute
            these MMIs.
:END:
#+end_note
#+begin_src elisp :results silent
  (defun egcd (a b)
    "Computes the greatest common divisor of a and b recursively.
     This extended version returns a list of d, x and y, where
     d = ax + by = gcd(a, b)."
    (if (zerop b)
        (list a 1 0)
      (let ((q (/ a b))
            (r (% a b)))
        (destructuring-bind (d x y) (egcd b r)
          (list d y (- x (* q y)))))))

  (defun find-y (o m)
    (second (egcd o m)))

  (defun crt (rs ms)
    (let* ((M (apply '* ms))
           (os (mapcar (lambda (m) (/ M m)) ms))
           (ys (mapcar* 'find-y os ms)))
      (mod (apply '+ (mapcar* '* rs os ys)) M)))
#+end_src
#+begin_src elisp
(crt '(4 2 9 4) '(5 7 11 13))
#+end_src

#+results:
: 394

** DONE JQA
   CLOSED: [2020-02-20 Thu 16:44]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 3

   x \equiv_{11} 5

   x \equiv_{13} 4
#+end_note
#+begin_src elisp
(crt '(3 5 4) '(7 11 13))
#+end_src

#+results:
: 654

** DONE GRZ
   CLOSED: [2020-02-20 Thu 16:45]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 3

   x \equiv_{11} 2

   x \equiv_{13} 1
#+end_note
#+begin_src elisp
(crt '(3 2 1) '(7 11 13))
#+end_src

#+results:
: 794

** DONE JYA
   CLOSED: [2020-02-20 Thu 16:46]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 2

   x \equiv_{11} 3

   x \equiv_{13} 4
#+end_note
#+begin_src elisp
(crt '(2 3 4) '(7 11 13))
#+end_src

#+results:
: 212

** DONE GXF
   CLOSED: [2020-02-20 Thu 16:46]
#+begin_note
   What is a 3-digit positive simultaneous solution to the following system of
   linear congruences?

   x \equiv_7 0

   x \equiv_{11} 8

   x \equiv_{13} 12
#+end_note
#+begin_src elisp
(crt '(0 8 12) '(7 11 13))
#+end_src

#+results:
: 987

* Problems
  Note: * means optional. If it\rsquo{}s not starred, it\rsquo{}s required.
** TODO XAJ *
#+begin_note
  Are there any 3-digit (d_{1}d_{2}d_{3}) positive simultaneous solutions to a system of
  linear congruences

   x \equiv_7 r_1

   x \equiv_{11} r_2

   x \equiv_{13} r_3

  with the property that d_1 = r_1, d_2 = r_2, and d_3 = r_3?
#+end_note
#+begin_info
  Your answer goes here.
#+end_info
** DONE JPZ
   CLOSED: [2020-02-19 Wed 18:39]
#+begin_note
  If p and q are coprime positive integers, then does a bijection necessarily
  exist between $\mathbb{Z}_{pq}$ and $\mathbb{Z}_{p} \times \mathbb{Z}_{q}$?

  Explain what the following code does, and how:
#+begin_src elisp
  (let* ((p 3)
         (q 5)
         (z-pq (number-sequence 0 (* p q))))
      (mapcar* 'list z-pq
               (mapcar (lambda (n) (mod n p)) z-pq)
               (mapcar (lambda (n) (mod n q)) z-pq)))
#+end_src

  Imagine the above code were wrapped in a function definition with p and q
  passed as parameters instead of bound in the =let=, then compare this function
  to the =mystery= function. Which function would be more in the functional
  programming style?
#+end_note
#+begin_info
The function is creating a table ranging from 0 to the product of p an q.
The function then finds mod of each number according to p and q.
The function is completing this task by first creating a list called z-pq
that ranges from 0 to the product of p and q. It then gathers a list of lists
that has three entries. First the element of z-pq, then that number mod p, then
that number mod q. This uses mapcar to iterate though z-pq and a lambda function
that calculates the mod.
#+end_info
#+begin_src elisp
  (let* ((p 3)
         (q 5)
         (z-pq (number-sequence 0 (* p q))))
      (mapcar* 'list z-pq
               (mapcar (lambda (n) (mod n p)) z-pq)
               (mapcar (lambda (n) (mod n q)) z-pq)))
#+end_src

#+results:
|  0 | 0 | 0 |
|  1 | 1 | 1 |
|  2 | 2 | 2 |
|  3 | 0 | 3 |
|  4 | 1 | 4 |
|  5 | 2 | 0 |
|  6 | 0 | 1 |
|  7 | 1 | 2 |
|  8 | 2 | 3 |
|  9 | 0 | 4 |
| 10 | 1 | 0 |
| 11 | 2 | 1 |
| 12 | 0 | 2 |
| 13 | 1 | 3 |
| 14 | 2 | 4 |
| 15 | 0 | 0 |

** DONE XFO
   CLOSED: [2020-02-21 Fri 09:49]
  The Chinese Remainder Theorem makes possible the use of a /residue number
  system/ to do computer arithmetic with \ldquo{}large\rdquo integers, where largeness is
  relative. Large in practice means numbers with hundreds or thousands of
  digits. For this problem, large means no greater than 1000. Normally,
  arithmetic with numbers in this range would be trivial, but the normal
  arithmetic operations of addition, subtraction, and multiplication are to be
  viewed as quite expensive. You must find ways to avoid using them.
  Exponentially more expensive are the division and modulus operations --- avoid
  these especially!

  Use the code below as a guide and a starting point, finish implementing the
  =to-rns=, =from-rns=, =add2= and =mul2= functions, and then in separate code
  blocks, write test code that can correctly add and multiply one-, two-, and
  three-digit nonnegative integers, converting to rns, doing the rns operations,
  then converting back from rns.

  /Avoid at all costs/ the use of =+=, =-=, =*=, =/=, =%=, or =mod=!

  You will benefit greatly if you write helper functions and use good functional
  programming style throughout.

#+begin_src elisp
  (defun to-rns (n)
    "Convert a normal integer between 0 and 1000 to its rns modulo
    1001 representation."
    )

  (defun from-rns (rns)
    "Convert from an rns modulo 1001 integer back to its normal
    representation."
    )

  (defun add2 (rns1 rns2)
    "Add two rns modulo 1001 integers to produce their rns sum."
    )

  (defun mul2 (rns1 rns2)
    "Multiply two rns modulo 1001 integers to produce their rns
    product."
    )
#+end_src

  The rest of the code is good as is. Note the mention in the documentation of
  the $\mathbb{Z}_7$, $\mathbb{Z}_{11}$, and $\mathbb{Z}_{13}$ residue sets. Recall
  that a $\mathbb{Z}_n$ residue set is just the possible remainders when modding
  by n, i.e., [0 1 2 3 \dots n-1].

#+name: a71113m71113
#+begin_src elisp :results silent
  (defun a7 (i j)
    "Add two nonnegative integers in the Z_7 residue set to produce
     a sum in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal addition/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 7) (< j 7))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0 1 2 3 4 5 6]
                 [1 2 3 4 5 6 0]
                 [2 3 4 5 6 0 1]
                 [3 4 5 6 0 1 2]
                 [4 5 6 0 1 2 3]
                 [5 6 0 1 2 3 4]
                 [6 0 1 2 3 4 5]] i) j))

  (defun a11 (i j)
    "Add two nonnegative integers in the Z_11 residue set to produce
     a sum in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal addition/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 11) (< j 11))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[ 0  1  2  3  4  5  6  7  8  9 10]
                 [ 1  2  3  4  5  6  7  8  9 10  0]
                 [ 2  3  4  5  6  7  8  9 10  0  1]
                 [ 3  4  5  6  7  8  9 10  0  1  2]
                 [ 4  5  6  7  8  9 10  0  1  2  3]
                 [ 5  6  7  8  9 10  0  1  2  3  4]
                 [ 6  7  8  9 10  0  1  2  3  4  5]
                 [ 7  8  9 10  0  1  2  3  4  5  6]
                 [ 8  9 10  0  1  2  3  4  5  6  7]
                 [ 9 10  0  1  2  3  4  5  6  7  8]
                 [10  0  1  2  3  4  5  6  7  8  9]] i) j))

  (defun a13 (i j)
    "Add two nonnegative integers in the Z_13 residue set to produce
     a sum in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal addition/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 13) (< j 13))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
                 [ 1  2  3  4  5  6  7  8  9 10 11 12  0]
                 [ 2  3  4  5  6  7  8  9 10 11 12  0  1]
                 [ 3  4  5  6  7  8  9 10 11 12  0  1  2]
                 [ 4  5  6  7  8  9 10 11 12  0  1  2  3]
                 [ 5  6  7  8  9 10 11 12  0  1  2  3  4]
                 [ 6  7  8  9 10 11 12  0  1  2  3  4  5]
                 [ 7  8  9 10 11 12  0  1  2  3  4  5  6]
                 [ 8  9 10 11 12  0  1  2  3  4  5  6  7]
                 [ 9 10 11 12  0  1  2  3  4  5  6  7  8]
                 [10 11 12  0  1  2  3  4  5  6  7  8  9]
                 [11 12  0  1  2  3  4  5  6  7  8  9 10]
                 [12  0  1  2  3  4  5  6  7  8  9 10 11]] i) j))

  (defun m7 (i j)
    "Multiply two nonnegative integers in the Z_7 residue set to produce
     a product in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal multiplication/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 7) (< j 7))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0  0  0  0  0  0  0]
                 [0  1  2  3  4  5  6]
                 [0  2  4  6  1  3  5]
                 [0  3  6  2  5  1  4]
                 [0  4  1  5  2  6  3]
                 [0  5  3  1  6  4  2]
                 [0  6  5  4  3  2  1]] i) j))

  (defun m11 (i j)
    "Multiply two nonnegative integers in the Z_11 residue set to produce
     a product in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal multiplication/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 11) (< j 11))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0  0  0  0  0  0  0  0  0  0  0]
                 [0  1  2  3  4  5  6  7  8  9 10]
                 [0  2  4  6  8 10  1  3  5  7  9]
                 [0  3  6  9  1  4  7 10  2  5  8]
                 [0  4  8  1  5  9  2  6 10  3  7]
                 [0  5 10  4  9  3  8  2  7  1  6]
                 [0  6  1  7  2  8  3  9  4 10  5]
                 [0  7  3 10  6  2  9  5  1  8  4]
                 [0  8  5  2 10  7  4  1  9  6  3]
                 [0  9  7  5  3  1 10  8  6  4  2]
                 [0 10  9  8  7  6  5  4  3  2  1]] i) j))

  (defun m13 (i j)
    "Multiply two nonnegative integers in the Z_13 residue set to produce
     a product in that set. Error check to ensure the inputs are valid,
     and use table lookup instead of normal multiplication/mod."
    (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 13) (< j 13))
      (error "bad parameters %s and/or %s" i j))
    (aref (aref [[0  0  0  0  0  0  0  0  0  0  0  0  0]
                 [0  1  2  3  4  5  6  7  8  9 10 11 12]
                 [0  2  4  6  8 10 12  1  3  5  7  9 11]
                 [0  3  6  9 12  2  5  8 11  1  4  7 10]
                 [0  4  8 12  3  7 11  2  6 10  1  5  9]
                 [0  5 10  2  7 12  4  9  1  6 11  3  8]
                 [0  6 12  5 11  4 10  3  9  2  8  1  7]
                 [0  7  1  8  2  9  3 10  4 11  5 12  6]
                 [0  8  3 11  6  1  9  4 12  7  2 10  5]
                 [0  9  5  1 10  6  2 11  7  3 12  8  4]
                 [0 10  7  4  1 11  8  5  2 12  9  6  3]
                 [0 11  9  7  5  3  1 12 10  8  6  4  2]
                 [0 12 11 10  9  8  7  6  5  4  3  2  1]] i) j))
#+end_src
:HINT:
  - Hint :: For =to-rns= and =from-rns=, =assoc= and =rassoc= are recommended.
            Thus the creation of an association list (alist) is a prerequisite
            for using these functions. The challenge is to create this alist
            without using mod (or %) or loops.
:END:
#+begin_src elisp :results silent
(let*
   ((n (number-sequence 0 (* 7 11 13)))
    (sv 6)
    (ev 10)
    (th 12))
   (mapcar (lambda (n) (list n (setq sv (a7 sv 1)) (setq ev (a11 ev 1)) (setq th (a13 th 1)))) n))

  (defun to-rns (x)
    "Convert a normal integer between 0 and 1000 to its rns modulo
    1001 representation."
    (cdr (assoc x (let*
                ((n (number-sequence 0 (* 7 11 13)))
                 (sv 6)
                 (ev 10)
                 (th 12))
                (mapcar (lambda (n) (list n (setq sv (a7 sv 1)) (setq ev (a11 ev 1)) (setq th (a13 th 1)))) n)))))

  (defun from-rns (x)
    "Convert from an rns modulo 1001 integer back to its normal
    representation."
    (car (rassoc x (let*
                ((n (number-sequence 0 (* 7 11 13)))
                 (sv 6)
                 (ev 10)
                 (th 12))
                (mapcar (lambda (n) (list n (setq sv (a7 sv 1)) (setq ev (a11 ev 1)) (setq th (a13 th 1)))) n)))))

  (defun add2 (rns1 rns2)
    "Add two rns modulo 1001 integers to produce their rns sum."
    (let*
       ((x (from-rns rns1))
        (y (from-rns rns2)))
       ((to-rns (+ x y)))))

  (defun mul2 (rns1 rns2)
    "Multiply two rns modulo 1001 integers to produce their rns
    product."
    (let*
       ((x (from-rns rns1))
        (y (from-rns rns2)))
       ((to-rns (* x y)))))
#+end_src
#+begin_src elisp
(to-rns 80)
#+end_src

#+results:
| 3 | 3 | 2 |

#+begin_src elisp
(from-rns '(0 0 3))
#+end_src

#+results:
: 770

#+begin_src elisp
(add2 '(3 3 2) '(0 0 3)) ;; 80 and 770
#+end_src

#+results:
| 3 | 3 | 5 |

#+begin_src elisp
(mul2 '(3 3 2) '(0 0 3)) ;; 80 and 770
#+end_src
* Puzzles
  The first puzzle is from the book. The second not-from-the-book puzzle is
  really a GPAO.
** TODO GYI
#+begin_note
   These eight small-number triples are not random:

   [[1 1 3] [1 1 4] [1 4 3] [1 4 4] [2 1 3] [2 1 4] [2 4 3] [2 4 4]]

   They have something to do with the product of the first three odd primes and
   the fourth power of two.

   Find the connection.
:HINT:
  - Hint :: This problem involves the Chinese Remainder Theorem. Use of the
            =crt-solve= function in the solution to GMY should help in your
            problem-solving investigation!
:END:
#+end_note
*** Rephrase
*** Approach
*** Solution
*** Proof

** TODO LBT
   A Bus Ticket has six digits (0-9). A ticket is lucky if the first three digits
   sum to the same number as the last three digits. For example, the following
   are all lucky:

   - 000000
   - 999999
   - 123420
   - 961088

   How many Lucky Bus Tickets are there?

   Find the answer *without* using brute-force exhaustive search (like the code
   below does):
#+begin_src elisp :results silent
  (defun sum-of-digits (n)
    (if (zerop n)
        0
      (+ (mod n 10) (sum-of-digits (/ n 10)))))
#+end_src

#+begin_src elisp
  (loop for n from 0 to 999999
        count (= (sum-of-digits (/ n 1000))
                 (sum-of-digits (% n 1000))))
#+end_src
